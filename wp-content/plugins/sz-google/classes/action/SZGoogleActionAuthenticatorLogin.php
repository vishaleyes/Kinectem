<?php

/**
 * Define a class that identifies an action called by the
 * main module based on the options that have been activated
 *
 * @package SZGoogle
 * @subpackage Actions
 * @author Massimo Della Rovere
 * @license http://opensource.org/licenses/gpl-license.php GNU Public License
 */

if (!defined('SZ_PLUGIN_GOOGLE') or !SZ_PLUGIN_GOOGLE) die();

// Before the definition of the class, check if there is a definition 
// with the same name or the same as previously defined in other script.

if (!class_exists('SZGoogleActionAuthenticatorLogin'))
{
	class SZGoogleActionAuthenticatorLogin extends SZGoogleAction
	{
		/**
		 * Add in the builder phase filters and 
		 * actions necessary to control login coded time
		 */

		function __construct()
		{
			add_action('login_form'  ,array($this,'addAuthenticatorLoginForm'));
			add_action('login_footer',array($this,'addAuthenticatorLoginJavascript'));
			add_filter('authenticate',array($this,'addAuthenticatorCheckCode'),30,3);
		}

		/**
		 * Add the input field that concerns the security code that
		 * is generated by the application of google authenticator
		 */

		function addAuthenticatorLoginForm() 
		{
			echo '<p><label title="'.SZGoogleCommon::getTranslate("If you don't use Authenticator leave this field empty.",'sz-google').'">'.ucwords(SZGoogleCommon::getTranslate('google authenticator code','sz-google')).'<br/>';
			echo '<input type="text" name="googleauthotp" id="googleauthotp" class="input" value="" size="20"/></label></p>';
		}

		/**
		 * Function to add a javascript code at the bottom of
		 * the form login in order to disable the autocomplete
		 */

		function addAuthenticatorLoginJavascript() 
		{
			echo '<script type="text/javascript">';
			echo "document.getElementById('googleauthotp').setAttribute('autocomplete','off');";
			echo '</script>';
		}

		/**
		 * Function for checking authorization to add as
		 * a primary filter to control user and password
		 */

		function addAuthenticatorCheckCode($userobj,$username,$password) 
		{
			// If option at the user level is off I go out from the procedure
			// without other controls on the verification code twice

			if (!isset($userobj->ID) or trim(get_user_option('sz_google_authenticator_enabled',$userobj->ID)) != '1') {
				return $userobj;
			}

			// Checking and setting variables and secret code entered
			// A profile is stored in the master and the other is passed by login

			if (empty($_POST['googleauthotp'] )) $authenticator = '';
				else $authenticator = trim($_POST['googleauthotp']);

			$options = $this->getModuleOptions('SZGoogleModuleAuthenticator');
			$secrets = trim(get_user_option('sz_google_authenticator_secret',$userobj->ID));

			// Control code inserted into the login form
			// with those in the table of secret codes Emergency

			if ($options['authenticator_emergency_codes'] == '1') 
			{
				$em = unserialize(trim(get_user_option('sz_google_authenticator_codes',$userobj->ID)));

				if (is_array($em) and isset($em[$authenticator]) and $em[$authenticator] == false ) 
				{
					$em[$authenticator] = time();
					update_user_option($userobj->ID,'sz_google_authenticator_codes',serialize($em),true);
					return $userobj;
				}
			}

			// Control code inserted into the login form with
			// that calculated routine internal authenticator class

			if ($this->checkAuthenticatorCode($secrets,$authenticator,$options['authenticator_discrepancy']) === true) return $userobj;
				else return new WP_Error('invalid_google_authenticator_password',SZGoogleCommon::getTranslate('<strong>ERROR</strong>: Authenticator code is incorrect.','sz-google'));
		}

		/**
		 * Check if the code is correct. This will accept codes starting 
		 * from $discrepancy*30sec ago to $discrepancy*30sec from now
		 */

		function checkAuthenticatorCode($secret,$code,$discrepancy=1)
		{
			if (strlen($code) != 6) return false;

			// Execution procedure for the calculation of the code and comparison 
			// with the code entered in the form of login (verification)

			if (!is_numeric($discrepancy)) $discrepancy=1;
				else $discrepancy = (int) $discrepancy;

			$currentTimeSlice = floor(time()/30);

			for ($i = -$discrepancy; $i <= $discrepancy; $i++) {
				if ($code == $this->getAuthenticatorCode($secret,$currentTimeSlice+$i)) {
					return true;
				}
			}

			return false;
		}

		/**
		 * Calculate the code, with given secret and point in time
		 * See the comments to follow all the necessary steps
		 */

		function getAuthenticatorCode($secret,$timeSlice=null)
		{
			if ($timeSlice === null) {
				$timeSlice = floor(time() / 30);
			}

			$secretkey = $this->_base32Decode($secret);

			$time     = chr(0).chr(0).chr(0).chr(0).pack('N*', $timeSlice);	// Pack time into binary string
			$hm       = hash_hmac('SHA1', $time, $secretkey, true);			// Hash it with users secret key
			$offset   = ord(substr($hm, -1)) & 0x0F;						// Use last nipple of result as index/offset
			$hashpart = substr($hm, $offset, 4);							// grab 4 bytes of the result
			$value    = unpack('N', $hashpart);								// Unpak binary value
			$value    = $value[1];											// Unpak binary value
			$value    = $value & 0x7FFFFFFF;								// Only 32 bits
			$modulo   = pow(10,6);

			return str_pad($value % $modulo,6,'0',STR_PAD_LEFT);
		}

		/**
		 * Helper class to decode base32
		 * is used to decrypt the string that must be verified
		 */

		private function _base32Decode($secret)
		{
			if (empty($secret)) return '';

			$base32chars = $this->_getBase32LookupTable();
			$base32charsFlipped = array_flip($base32chars);

			$paddingCharCount = substr_count($secret, $base32chars[32]);
			$allowedValues = array(6, 4, 3, 1, 0);

			if (!in_array($paddingCharCount, $allowedValues)) return false;

			for ($i = 0; $i < 4; $i++) {
				if ($paddingCharCount == $allowedValues[$i] &&
				substr($secret, -($allowedValues[$i])) != str_repeat($base32chars[32], $allowedValues[$i])) return false;
			}

			$secret = str_replace('=','', $secret);
			$secret = str_split($secret);
			$binaryString = "";

			for ($i = 0; $i < count($secret); $i = $i+8) {
				$x = "";
				if (!in_array($secret[$i], $base32chars)) return false;
				for ($j = 0; $j < 8; $j++) {
					$x .= str_pad(base_convert(@$base32charsFlipped[@$secret[$i + $j]], 10, 2), 5, '0', STR_PAD_LEFT);
				}
				$eightBits = str_split($x, 8);
				for ($z = 0; $z < count($eightBits); $z++) {
					$binaryString .= ( ($y = chr(base_convert($eightBits[$z], 2, 10))) || ord($y) == 48 ) ? $y:"";
				}
			}
			return $binaryString;
		}

		/**
		 * Table 32 characters with the set that is to be used
		 * during the encoding or decoding function in base32()
		 */

		private function _getBase32LookupTable()
		{
			return array(
				'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', //  7
				'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', // 15
				'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', // 23
				'Y', 'Z', '2', '3', '4', '5', '6', '7', // 31
				'='  // padding char
			);
		}
	}
}